import java.util.concurrent.locks.ReentrantLock
import org.eclipse.smarthome.model.script.ScriptServiceUtil
import java.util.HashMap

val ReentrantLock arduino_writer = new ReentrantLock
val ReentrantLock auto_runner_lock = new ReentrantLock
val Integer sensor_default_hyst = 20
val Integer sensor_default_dark = 80
val Integer sensor_default_sunshine = 200
val Integer default_lockout_time = 5 // default time in minutes to wait after engine run (valid for automation mode only)

var HashMap<String, HashMap<String, Object>> EngineConfig = newHashMap(
//var EngineConfig = newHashMap(
    "Z1_S_PETER_BIG" -> (newHashMap(
            "Commander_id"        -> 10 as Integer, // Remote commander block controling engine
            "Engine_id"        -> 1 as Integer, // Engine number on given commander
            "Timer"    -> null as Timer // Timer to prevent too frequent changes
//            "LastRun" -> now.minusMinutes(1024) as DateTimeType, // Time of last run
//            "LastManualOrder" -> 10 as Integer, // Last manual order for automation detection, 0=STOP; 1=DOWN; 2=UP; 10=NONE
//            "locked_after_manual_run" -> 33 as Integer // Time in minutes that it is locked after last run
        ))
)

rule "Startup"
  when 
    System started
  then
    logInfo ("STARTUP", "System Starting from startup rule")
    if ( S_light_southffxDarkTreshold.state == NULL ) { S_light_southffxDarkTreshold.postUpdate(sensor_default_dark) }
    if ( S_light_southffxSunshineTreshold.state == NULL ) { S_light_southffxSunshineTreshold.postUpdate(sensor_default_sunshine) }
end

rule "direct_run_gZx_group"
  when
    Member of gZ_ALL received command
  then
    try {
      logInfo("Rollershutter", "Member " + triggeringItem.name + " received " + receivedCommand)
      arduino_writer.lock()
      val String split_part0 = triggeringItem.name.toString.split("x").get(0)
      val String split_part1 = triggeringItem.name.toString.split("x").get(1)
      val String split_part2 = triggeringItem.name.toString.split("x").get(2)
      if (receivedCommand == DOWN) {
        ARDUINO_SEND_Args.sendCommand(split_part1 + " " + split_part2 +" 1")
        ARDUINO_SEND.sendCommand(ON)
        postUpdate (split_part0 + "xLastRunDirection","1")
        postUpdate(split_part0 + "xLastRunTime", new DateTimeType().toString)
      }
      if (receivedCommand == UP) {
//        logInfo ("Rollershutter", "GOING UP " + split_part0 + "|" +  split_part0 as String)
        ARDUINO_SEND_Args.sendCommand(split_part1 + " " + split_part2 +" 2")
        ARDUINO_SEND.sendCommand(ON)
        postUpdate (split_part0 + "xLastRunDirection","2")
        postUpdate(split_part0 + "xLastRunTime", new DateTimeType().toString)
      }
      if (receivedCommand == STOP) {
        ARDUINO_SEND_Args.sendCommand(split_part1 + " " + split_part2 +" 0")
        ARDUINO_SEND.sendCommand(ON)
        //postUpdate (split_part0 + "xLastRunDirection",0) //Commented out as for stop we keep last direction used before
        postUpdate(split_part0 + "xLastRunTime", new DateTimeType().toString)
      }
      logInfo("Rollershutter", "Member " + triggeringItem.name + " received " + receivedCommand + " translated to" + split_part1 + "+" + split_part2 )
    }catch(Throwable t) {}
    finally {
        arduino_writer.unlock()
    }
end

rule "Sensor triggers" 
  when
    Member of g_TRIGGER_ALL changed
  then
    val String split_part0 = triggeringItem.name.toString.split("x").get(0)
    val local_tiggered_group_name = split_part0 + "xTRIGGER"
    val local_tiggered_group_item = ScriptServiceUtil.getItemRegistry.getItem(local_tiggered_group_name) as GenericItem
    local_tiggered_group_item.allMembers.forEach [i | i.postUpdate (ON) ]
end

rule "South SLD"
// 0:Sunshine 1:Light 2:Dark
  when
    Item S_light_southffxINRAW changed
  then
    //logInfo("Light", "Light changed input is " + S_light_southffxSLD.state + "/" + S_light_southffxINRAW.state)
    if ( S_light_southffxDarkTreshold.state == NULL ) { S_light_southffxDarkTreshold.postUpdate(sensor_default_dark) }
    if ( S_light_southffxSunshineTreshold.state == NULL ) { S_light_southffxSunshineTreshold.postUpdate(sensor_default_sunshine) }
    if ( S_light_southffxSLD.state == NULL ) {
      if ( (S_light_southffxINRAW.state as Number) <= (S_light_southffxDarkTreshold.state as Number) ) { S_light_southffxSLD.sendCommand (2) }
      else if ( (S_light_southffxINRAW.state as Number) <= (S_light_southffxSunshineTreshold.state as Number) ) { S_light_southffxSLD.sendCommand (1) }
      else if ( (S_light_southffxINRAW.state as Number) > (S_light_southffxSunshineTreshold.state as Number) ) { S_light_southffxSLD.sendCommand (0) }
    }
    else {
      if ( (S_light_southffxSLD.state as Number) == 0 ) {
        if ( (S_light_southffxINRAW.state as Number) <= (S_light_southffxDarkTreshold.state as Number) ) { S_light_southffxSLD.sendCommand (2) }
        else if ( (S_light_southffxINRAW.state as Number) <= ((S_light_southffxSunshineTreshold.state as Number) - sensor_default_hyst)) { S_light_southffxSLD.sendCommand (1) }
      }
      if ( (S_light_southffxSLD.state as Number) == 1 ) {
        if ( (S_light_southffxINRAW.state as Number) >= ((S_light_southffxSunshineTreshold.state as Number) + sensor_default_hyst) ) { S_light_southffxSLD.sendCommand (0) }
        else if ( (S_light_southffxINRAW.state as Number) <= ((S_light_southffxDarkTreshold.state as Number) - sensor_default_hyst)) { S_light_southffxSLD.sendCommand (2) }
      }
      if ( (S_light_southffxSLD.state as Number) == 2 ) {
        if ( (S_light_southffxINRAW.state as Number) >= (S_light_southffxSunshineTreshold.state as Number) ) { S_light_southffxSLD.sendCommand (0) }
        else if ( (S_light_southffxINRAW.state as Number) >= ((S_light_southffxDarkTreshold.state as Number) + sensor_default_hyst)) { S_light_southffxSLD.sendCommand (1) }
      }
    }
end

rule "test run"
  when
    Member of gTEST received command
  then
    try {
      logInfo("TEST", "Before return")
      //return;
      logInfo("TEST", "After return")
    }catch(Throwable t) {}
    finally {
      logInfo("TEST", "Finally")
    }
end

rule "Test item name change"
  // based on https://community.openhab.org/t/design-pattern-working-with-groups-in-rules/20512
  when
    Item Z1_S_TSTxMAIN received command
  then
    val String split_part0 = triggeringItem.name.toString.split("x").get(0)
    val String split_part1 = triggeringItem.name.toString.split("x").get(1)
    logInfo ("Test", "Split as " + split_part0 + " and " + split_part1)
    val local_ItemName = split_part0 + "xEngine"
    val local_EngineNumber = ScriptServiceUtil.getItemRegistry.getItem(local_ItemName)
    local_EngineNumber.postUpdate (47)
    logInfo ("Test", "Item value " + local_EngineNumber.state + "vs" + Z1_S_TSTxEngine.state)
end
